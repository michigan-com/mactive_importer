# -*- coding utf-8 -*-
import re
import unittest
import random
from xml.etree.ElementTree import XML
from datetime import date

from ..parse_html import parse_content
from ..parse_xml import parse_obits, sorted_nicely

xml_feed_format = '''<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<web-export>
    <run-date>{run_date}
        {obits}
    </run-date>
</web-export>
'''

xml_obit_format = '''
<pub-code>Internet
    <ad-type>Death Notice
        <cat-code>Death Notices</cat-code>
        <class-code>Death Notices</class-code>
        <subclass-code>{subclass_code}</subclass-code>
        <subclass3-code></subclass3-code>
        <subclass4-code></subclass4-code>
        <ad-number>{ad_number}</ad-number>
        <start-date>{start_date}</start-date>
        <end-date>{end_date}</end-date>
        <FieldedDataSet>
            <DNfirstname>{first_name}</DNfirstname>
            <DNlastname>{last_name}</DNlastname>
            <publication>DMP</publication>
        </FieldedDataSet>
        <ad-content>
            <![CDATA[{ad_content}]]>
        </ad-content>
    </ad-type>
</pub-code>
'''

# General format of <ad-content> tag
ad_content_format = '<font>{first_name}</font><font>{last_name}</font><font>{content}</font>'

img_regex = re.compile('<img(p)?[^\>]*>')

class TestParse(unittest.TestCase):
    defaults = {
        'first_name': 'TestFirstName',
        'last_name': 'TestLastName',
        'subclass_code': '0010',
        'ad_number': '0123456-01',
        'ad_content': 'test add content'
    }

    def generate_test_obit_xml(self, subclass_code=defaults['subclass_code'],
            ad_number=defaults['ad_number'], start_date=date.today(),
            end_date=date.today(), first_name=defaults['first_name'],
            last_name=defaults['last_name'], ad_content=defaults['ad_content']):
        return xml_obit_format.format(subclass_code=subclass_code, ad_number=ad_number,
                start_date=start_date, end_date=end_date, first_name=first_name,
                last_name=last_name, ad_content=ad_content)

    def generate_test_feed_xml(self, obits=[]):
        """ Generate the xml feed

            :param obits: list of strings generated by self.generate_test_obit_xml
        """
        return xml_feed_format.format(run_date=date.today(), obits='\n'.join(obits))

    def test_get_obit(self):
        feed = self.generate_test_feed_xml([self.generate_test_obit_xml()])
        root = XML(feed)

        obits = list(parse_obits(root))

        self.assertEqual(len(obits), 1, 'should be one obit')

        obit = obits[0]
        for key in self.defaults:
            if key == 'ad_content':
                continue
            self.assertTrue(hasattr(obit, key), 'Attr {} not found in obit'.format(key))
            self.assertEqual(obit.__getattribute__(key), self.defaults[key],
                    'Attribute {} doesn\'t match up'.format(key))


    def test_parse_content(self):
        first_name = self.defaults['first_name']
        last_name = self.defaults['last_name']
        ad_content = self.defaults['ad_content']
        content = ad_content_format.format(first_name=first_name,
                last_name=last_name, content=ad_content)

        fed, images = parse_content(content, first_name, last_name)

        # This is what we expect fed to be
        expected_fed = ''.join([first_name, '{} '.format(last_name), ad_content])
        self.assertEqual(fed, expected_fed, 'invalid fed')

        self.assertEqual(len(images), 0, 'Should not be any images')

    def test_parse_content_images(self):
        img_names = ['123.jpg', '456.png']
        first_name = self.defaults['first_name']
        last_name = self.defaults['last_name']
        ad_content = 'This is the add content. <img src="{}"> There\'s one image tag. Here\'s another <imgp src="{}">'.format(*img_names)
        content = ad_content_format.format(first_name=first_name,
                last_name=last_name, content=ad_content)

        fed, images = parse_content(content, first_name, last_name)

        self.assertEqual(len(images), len(img_names), 'Incorrect number of imgs')
        for img in images:
            self.assertTrue(img in img_names, 'Img {} not found'.format(img))

        expected_fed = ''.join([first_name, '{} '.format(last_name), img_regex.sub('', ad_content)])
        self.assertEqual(fed, expected_fed, 'invalid fed')

    def test_sort_nicely(self):
        imgs = []
        for i in range(0, 20):
            file_extension = 'png' if i % 2 else 'jpg'
            imgs.append('{}.{}'.format(random.randint(0, 10000), file_extension))

        sorted = sorted_nicely(imgs)

        last = None
        for img in sorted:
            num = int(re.sub('\D', '', img))
            if last is None:
                last = num
                continue

            self.assertTrue(num > last, 'Incorrectly sorted: {} !> {}'.format(num, last))
